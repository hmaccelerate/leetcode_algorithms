

# 总结

[递归，回溯，DFS，BFS的理解和模板](http://chen-tao.github.io/2017/01/27/al-template/)

[DFS深度优先搜索算法总结](http://chen-tao.github.io/2017/01/26/about-dfs/)

[回溯算法入门级详解 + 练习（持续更新）](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

[回溯算法 + 剪枝（回溯经典例题详解）](https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)

# Binary Tree & Tree-based DFS

## 二叉树上求值，求路径

## [\257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)

### Analysis

- Data structure: Linkedlist
- Complexity Analysis
  - Time: O(n)
  - Space: O(n)

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        LinkedList<String> paths=new LinkedList();
        construct_paths(root,"",paths);
        return paths;
        
    }
    
    public void construct_paths(TreeNode root, String path, LinkedList<String> paths){
        if(root!=null){
            path+=Integer.toString(root.val);
            if((root.left==null)&&(root.right==null))
                paths.add(path);
            else{
                path+="->";
                construct_paths(root.left,path,paths);
                construct_paths(root.right,path,paths);
            }
        }
    }
}
```

### Reference

## [\124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)

### Analysis

**Algorithm**

Now everything is ready to write down an algorithm. I am going to use dfs.

- Initiate `max_sum` as the smallest possible integer and call `max_gain(node = root)`.
- Implement  max_gain(node) with a check to continue the old path/to start a new path:
  - Base case : if node is null, the max gain is `0`.
  - Call `max_gain` recursively for the node children to compute max gain from the left and right subtrees : `left_gain = max(max_gain(node.left), 0)` and
    `right_gain = max(max_gain(node.right), 0)`.
  - Now check to continue the old path or to start a new path. To start a new path would cost `price_newpath = node.val + left_gain + right_gain`. Update `max_sum` if it's better to start a new path.
  - For the recursion return the max gain the node and one/zero of its subtrees could add to the current path : `node.val + max(left_gain, right_gain)`.

- Data structure: Tree
- Complexity Analysis
  - Time complexity : O(*N*) where `N` is number of nodes, since we visit each node not more than 2 times.
  - Space complexity :O(log(*N*)). We have to keep a recursion stack of the size of the tree height, which is O(log(*N*)) for the binary tree.

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int max_sum=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        max_gain(root);
        return max_sum;
    }
    
    public int max_gain(TreeNode node){
        if(node==null) return 0;
        
        int left_gain= Math.max(max_gain(node.left),0);
        int right_gain= Math.max(max_gain(node.right),0);
        
        int price_newpath= node.val+left_gain+right_gain;
        
        max_sum=Math.max(max_sum,price_newpath);
        
        return node.val+ Math.max(left_gain,right_gain);
    }
}
```

### Reference

​	[Solution](https://leetcode.com/problems/binary-tree-maximum-path-sum/solution/)

## [\572. Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/submissions/)

### Analysis

- Data structure: Linkedlist
- Complexity Analysis
  - Time complexity : O(m^2+n^2+m*n)*. A total of n*n* nodes of the tree s*s* and m*m* nodes of tree t*t* are traversed. Assuming string concatenation takes O(k)*O*(*k*) time for strings of length k*k* and `indexOf` takes O(m*n)*.
  - Space complexity : O(max(m,n)). The depth of the recursion tree can go upto n*n* for tree t*t* and m*m* for tree s*s* in worst case.

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        String tree1=preOrder(s,true);
        String tree2=preOrder(t,true);
        return tree1.indexOf(tree2)>=0;
    }
    
    public String preOrder(TreeNode t, boolean left){
        if(t==null){
            if(left)
                return "lnull";
            else
                return "rnull";
        }
        return "#"+t.val+" "+preOrder(t.left,true)+preOrder(t.right,false);
    }
}
```

### Reference



## [Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree](https://leetcode.com/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/)

### Analysis

In my approach, I am going to use Depth-first search (DFS) with the parameters, the parameters are current node in the binary tree and current position in the array of integers.

When reaching at final position check if it is a leaf node.

- Data structure: Binary Tree
- Complexity Analysis
  - Time: O(n)
  - Space: O(logn)

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidSequence(TreeNode root, int[] arr) {
        if(root==null) return arr.length==0;
        return isValid(root,arr,0);
    }
    
    boolean isValid(TreeNode root, int[] arr,int idx){
        if(root.val!=arr[idx]) return false;
        if(idx== arr.length-1)
            return root.left==null&&root.right==null;
        return ((root.left!=null&&isValid(root.left,arr,idx+1)) || (root.right!=null&&isValid(root.right,arr,idx+1)));
    }
}
```

### Reference

## [\236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### Analysis

 Traverse the tree in a depth first manner. The moment you encounter either of the nodes `p` or `q`, return some boolean flag. The flag helps to determine if we found the required nodes in any of the paths. The least common ancestor would then be the node for which both the subtree recursions return a `True` flag. It can also be the node which itself is one of `p` or `q` and for which one of the subtree recursions returns a `True` flag.

**Algorithm**

1. Start traversing the tree from the root node.
2. If the current node itself is one of `p` or `q`, we would mark a variable `mid` as `True` and continue the search for the other node in the left and right branches.
3. If either of the left or the right branch returns `True`, this means one of the two nodes was found below.
4. If at any point in the traversal, any two of the three flags `left`, `right` or `mid` become `True`, this means we have found the lowest common ancestor for the nodes `p` and `q`.

- Data structure: Binary Tree
- Complexity Analysis
  - Time Complexity: *O*(*N*), where N*N* is the number of nodes in the binary tree. In the worst case we might be visiting all the nodes of the binary tree.
  - Space Complexity: *O*(*N*). This is because the maximum amount of space utilized by the recursion stack would be N*N* since the height of a skewed binary tree could be N*N*.

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private TreeNode ans;
    public Solution(){
        this.ans=null;
    }
    
    private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q){
        if(currentNode==null) return false;
        int left=this.recurseTree(currentNode.left,p,q)?1:0;
        int right= this.recurseTree(currentNode.right,p,q)?1:0;
        int mid=(currentNode==p || currentNode==q)?1:0;
        if(mid+left+right>=2) this.ans=currentNode;
        return (mid+left+right)>0;
            
    }
    
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        this.recurseTree(root,p,q);
        return ans;
    }
}
```

### Reference

[Solution](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/)

## [\510. Inorder Successor in BST II](https://leetcode.com/problems/inorder-successor-in-bst-ii/)

### Analysis

- Data structure
- **Complexity Analysis**
  - Time complexity : O(*H*), where *H* is the height of the tree. That means O(log*N*) in the average case, and O(*N*) in the worst case, where *N* is the number of nodes in the tree.
  - Space complexity : O(1), since no additional space is allocated during the calculation.

### Solution

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
};
*/

class Solution {
    public Node inorderSuccessor(Node node) {
        if(node.right!=null){
            node=node.right;
            while(node.left!=null)node=node.left;
            return node;
        }
        
        while(node.parent!=null&&node==node.parent.right)node=node.parent;
        return node.parent;
    }
}
```

### Reference

[Solution](https://leetcode.com/problems/inorder-successor-in-bst-ii/solution/)

## 二叉树结构变化

## [\114. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/)

### Analysis

We can find that the order of flatten of binary tree is the order of preorder travesal.

First, I am going to let the left tree of root move to the right side.

And then moving the right tree of root to the most right side of original left tree.

Then, we move to next right node of root and repeat operatons above. At the end, we can get the flatten binary tree.

可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。

将左子树插入到右子树的地方
将原来的右子树接到左子树的最右边节点
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null

- Data structure: Binary tree
- Complexity Analysis
  - Time Complexcity: O(n)
  - Space Complexcity: O(1)

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        while(root!=null){
            if(root.left==null){
            root=root.right;
        }
        else{
            TreeNode pre=root.left;
            while(pre.right!=null){
                pre=pre.right;
            }
            pre.right=root.right;
            root.right=root.left;
            root.left=null;
            root=root.right;
        }
        }
        
    }
}
```

### Reference

[详细通俗的思路分析，多解法](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/)

## 考察形态: Binary Search Tree

## [\449. Serialize and Deserialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst/)

### Analysis

- Data structure
  - Queue
  - Binary Search Tree
- Complexity Analysis

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb=new StringBuilder();
        serializerHelper(root,sb);
        return sb.toString();
    }
    private void serializerHelper(TreeNode root,StringBuilder sb){
        if(root==null) return;
        sb.append(root.val).append(",");
        serializerHelper(root.left,sb);
        serializerHelper(root.right,sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.isEmpty()) return null;
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        int noLessThan=Integer.MIN_VALUE;
        int noMoreThan=Integer.MAX_VALUE;
        return deserializerHelper(queue,noLessThan,noMoreThan);
    }
    
    private TreeNode deserializerHelper(Queue<String> queue,int noLessThan,int noMoreThan){
        if(queue.isEmpty()) return null;
        int curVal=Integer.parseInt(queue.peek());
        if(curVal<=noLessThan||curVal>=noMoreThan) return null;
        queue.poll();
        TreeNode curNode=new TreeNode(curVal);
        curNode.left=deserializerHelper(queue,noLessThan,curVal);
        curNode.right=deserializerHelper(queue,curVal,noMoreThan);
        return curNode;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// String tree = ser.serialize(root);
// TreeNode ans = deser.deserialize(tree);
// return ans;
```

### Reference

## []()

### Analysis

- Data structure
- Complexity Analysis

### Solution

```java

```

### Reference

## [\91. Decode Ways](https://leetcode.com/problems/decode-ways/)

### Analysis

 In my approach, I am going to use recursion. The most important point t in this problem is that at any given step when we are trying to decode a string of numbers it can either be a single digit decode or a double digit decode . This choice while decoding can lead to different combinations.

At any given time for a string we enter a recursion after successfully decoding two digits to a single character or a single digit to a character. This leads to multiple paths to decoding the entire string. If a given path leads to the end of the string this means we could successfully decode the string. If at any point in the traversal we encounter digits which cannot be decoded, we backtrack from that path and find another way to decode.

- Data structure： HashMap
- Complexity Analysis
  - Time Complexity: O*(*N*), where N*N* is length of the string. Memoization helps in pruning the recursion tree and hence decoding for an index only once. Thus this solution is linear time complexity.
  - Space Complexity: O*(*N*). The dictionary used for memoization would take the space equal to the length of the string. There would be an entry for each index value. The recursion stack would also be equal to the length of the string.

### Solution

```java
class Solution {
    HashMap<Integer,Integer> memo= new HashMap<>();
    private int recursiveWithMemo(int index, String str){
        if(index==str.length()) 
            return 1;
        if(str.charAt(index)=='0')
            return 0;
        if(index==str.length()-1)
            return 1;
        if(memo.containsKey(index))
            return memo.get(index);
        int ans= recursiveWithMemo(index+1,str);
        if(Integer.parseInt(str.substring(index,index+2))<=26){
            ans+=recursiveWithMemo(index+2,str);
        }
        memo.put(index,ans);
        return ans;
    }

    public int numDecodings(String s) {
        if(s==null||s.length()==0)
            return 0;
        
        return recursiveWithMemo(0,s);
        
    }
}
```

### Reference

## [Split Array into Fibonacci Sequence](https://leetcode.com/problems/split-array-into-fibonacci-sequence/)

### Analysis

- Data structure
- Complexity Analysis
  - Time complexcity: O(n*2)
  - Space Complexity: O(n)

### Solution

```java
class Solution {
   public List<Integer> splitIntoFibonacci(String S) {

        //字符串长度小于3直接返回
        if (S.length() < 3) return new ArrayList<>();
        int n = S.length();
        //第一个数字的长度不超过数组的一半和10两者的最小值
        for (int i = 1; i <= Math.min((n - 1) / 2, 10); i++) {
            //遇到00112这种
            if (i > 1 && S.charAt(0) == '0') {
                break;
            }
            //斐波那契数列中第一个数字的长度和第二个数字的长度都小于等于第三个数字的长度
            for (int j = i + 1; n - j >= i && n - j >= j - i; j++) {
                //遇到199001200这种
                if (S.charAt(i) == '0' && j - i > 1) {
                    break;
                }
                Long num1 = Long.valueOf(S.substring(0, i));
                Long num2 = Long.valueOf(S.substring(i, j));
                //大于int型最大值直接跳过
                if (num1 > Integer.MAX_VALUE || num2 > Integer.MAX_VALUE) {
                    break;
                }
                //用中间数组来保存中间值
                List<Integer> tempList = new ArrayList<>();
                tempList.add(Math.toIntExact(num1));
                tempList.add(Math.toIntExact(num2));
                if (canSplitIntoFibonacci(tempList, S.substring(j), Math.toIntExact(num1), Math.toIntExact(num2))) {
                    return tempList;
                }
            }
        }
        return new ArrayList<>();
    }

    private boolean canSplitIntoFibonacci(List<Integer> tempList, String str, Integer num1, Integer num2) {
        if (str.equals("")) {
            return true;
        }
        Integer sum = num1 + num2;
        String next = String.valueOf(sum);
        //剩下的部分一定要包含前两个数的结果
        if (!str.startsWith(next)) {
            return false;
        }
        tempList.add(sum);
        //将第二个数作为第一个数,结果作为第二个数,继续回溯
        return canSplitIntoFibonacci(tempList, str.substring(next.length()), num2, Integer.valueOf(sum));
    }

}
```

### Reference

[java回溯,参考306题中大佬的写法](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-can-kao-306ti-zhong-da-lao-de-xie-fa-by/)

## [\230. Kth Smallest Element in a BST]()

### Analysis

- Data structure: BST, list
- Complexity Analysis
  - Time Complexicity: O(n)
  - Space Complexicity: O(n)

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public ArrayList<Integer> inOrder(TreeNode root, ArrayList<Integer> arr){
        if(root==null) return arr;
        inOrder(root.left,arr);
        arr.add(root.val);
        inOrder(root.right,arr);
        return arr;
    }
    
    public int kthSmallest(TreeNode root, int k) {
        ArrayList<Integer> nums=inOrder(root,new ArrayList<Integer>());
        return nums.get(k-1);
    }
}
```

### Reference

[Solution](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution/)

## [\173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)

### Analysis

- Data structure: BST/ Stack
- **Complexity Analysis**
  - Time complexcity: O(1)
  - Space complexcity: O(h)

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class BSTIterator {
    Stack<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        this.stack=new Stack<TreeNode>();
        this._leftMostInorder(root);
    }
    
    public void _leftMostInorder(TreeNode root){
        while(root!=null){
            this.stack.push(root);
            root=root.left;
        }
    }
    
    /** @return the next smallest number */
    public int next() {
       TreeNode topmostNode= this.stack.pop();
        if(topmostNode.right!=null){
            this._leftMostInorder(topmostNode.right);
        }
       return topmostNode.val;
        
    }
    
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return this.stack.size()>0;
    }
}

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator obj = new BSTIterator(root);
 * int param_1 = obj.next();
 * boolean param_2 = obj.hasNext();
 */
```

### Reference

​	[Solution](https://leetcode.com/problems/binary-search-tree-iterator/solution/)

## [\270. Closest Binary Search Tree Value](https://leetcode.com/problems/closest-binary-search-tree-value/)

### Analysis

- Data structure: BST
- **Complexity Analysis**
  - Time: O(h)
  - Space:O(1)

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int closestValue(TreeNode root, double target) {
        return dfs(root,target,Double.MAX_VALUE,-1);
    }
    
    private int dfs(TreeNode root,double target, double diff, int currClosest){
        if(root==null) return currClosest;
        if(root.val==target) return root.val;
        else if(root.val<target){
            if(target-root.val<diff) return dfs(root.right,target,target-root.val,root.val);
            else return dfs(root.right,target,diff,currClosest);
        }else{
            if(root.val-target<diff) return dfs(root.left,target,root.val-target,root.val);
            else return dfs(root.left,target,diff,currClosest);
        }
    }
}
```

### Reference

[Java iterative solution](https://leetcode.com/problems/closest-binary-search-tree-value/discuss/70386/Java-iterative-solution)

## [\701. Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)

### Analysis

- Data structure
- Complexity Analysis
  - Time complexity : \mathcal{O}(H)O(*H*), where H*H* is a tree height. That results in \mathcal{O}(\log N)O(log*N*) in the average case, and \mathcal{O}(N)O(*N*) in the worst case.
  - Space complexity : \mathcal{O}(1)O(1) since it's a constant space solution.

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null) return new TreeNode(val);
        if(val>root.val)
            root.right=insertIntoBST(root.right,val);
        else
            root.left=insertIntoBST(root.left,val);
        return root;
    }
}
```

### Reference

[Solution](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution/)

## []()

### Analysis

- Data structure
- Complexity Analysis

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- Complexity Analysis

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- Complexity Analysis

### Solution

```java

```

### Reference

# Combination-base DFS

[A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))

## [\39. Combination Sum](https://leetcode.com/problems/combination-sum/)

### Analysis

- **Data structure**: ArrayList
- **Complexity Analysis**
  - Time Complexity: O(2^n)

### Solution

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> list=new ArrayList<>();
        backtrack(list,new ArrayList<>(),candidates,target,0);
        return list;
    }
    
    private void backtrack(List<List<Integer>> list,List<Integer> templist,int[] nums,int remain,int start){
        // 在数组有序的前提下，剪枝
        if(remain<0) return;
        // 由于 path 全局只使用一份，到叶子结点的时候需要做一个拷贝
        else if(remain==0) list.add(new ArrayList<>(templist));
        else{
            for(int i=start;i<nums.length;i++){
                templist.add(nums[i]);
                backtrack(list,templist,nums,remain-nums[i],i);
                //当remain<0，会多出一个元素，去掉
                templist.remove(templist.size()-1);
            }
        }
    }
}
```

### Reference

[回溯算法 + 剪枝](https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)

## [\40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> list=new ArrayList<>();
        backtrack(list,new ArrayList<>(),candidates,target,0);
        return list;
    }
    
    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums,int remain,int start){
        if(remain<0) return;
        else if(remain==0) list.add(new ArrayList<>(tempList));
        else{
            for(int i=start;i<nums.length;i++){
                if(i>start&&nums[i]==nums[i-1])
                    continue;
                tempList.add(nums[i]);
                backtrack(list,tempList,nums,remain-nums[i],i+1);
                tempList.remove(tempList.size()-1);
            }
        }
    }
}
```

### Reference

[回溯算法 + 剪枝](https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/)

## [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)

### Analysis

- Data structure
- **Complexity Analysis**
  - Time Complexity: O(2^n)

### Solution

```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> list=new ArrayList<>();
        backtrack(list,new ArrayList<>(),s,0);
        return list;
    }
    
    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){
        if(start==s.length()){
             list.add(new ArrayList<>(tempList));
        }else{
            for(int i=start;i<s.length();i++){
                if(isPalindrome(s,start,i)){
                    tempList.add(s.substring(start,i+1));
                    backtrack(list,tempList,s,i+1);
                    tempList.remove(tempList.si0ze()-1);
            }
        }
    }
}
        public boolean isPalindrome(String s,int low,int high){
        while(low<high){
            if(s.charAt(low++)!=s.charAt(high--))
                return false;
        }
        return true;
    }
}
```

### Reference

[回溯、优化（使用动态规划预处理数组）](https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/)

## [\78. Subsets](https://leetcode.com/problems/subsets/)

### Analysis

- Data structure
- **Complexity Analysis**
  - Time Complexity: O(*N*×2*N*)
  - Space Complexity: O(*N*×2*N*)

### Solution

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list=new ArrayList<>();
        backtrack(list,new ArrayList<>(),nums,0);
        return list;
    }
    public void backtrack(List<List<Integer>> list,List<Integer> tempList, int[] nums, int start){
        list.add(new ArrayList<>(tempList));
        for(int i=start;i<nums.length;i++){
            tempList.add(nums[i]);
            backtrack(list,tempList,nums,i+1);
            tempList.remove(tempList.size()-1);
        }
    }
}
```

### Reference

[二进制位，逐个枚举，DFS 三种思路，9+ 种以上的写法](https://leetcode-cn.com/problems/subsets/solution/er-jin-zhi-wei-zhu-ge-mei-ju-dfssan-chong-si-lu-9c/)



## [\90. Subsets II](https://leetcode.com/problems/subsets-ii/)

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> list=new ArrayList<>();
        backtrack(list,new ArrayList<>(),nums,0);
        return list;
    }
    
    public void backtrack(List<List<Integer>> list, List<Integer> tempList,int[] nums,int start){
        list.add(new ArrayList<>(tempList));
        for(int i=start;i<nums.length;i++){
            if(i>start&&nums[i]==nums[i-1])
                continue;
            tempList.add(nums[i]);
            backtrack(list,tempList,nums,i+1);
            tempList.remove(tempList.size()-1);
        }
    }
}
```

### Reference

## [Word Break ](https://leetcode.com/problems/word-break/)

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return word_break(s,new HashSet(wordDict),0,new Boolean[s.length()]);
    }
    
    public boolean word_break(String s,Set<String> wordDict,int start, Boolean[] memo){
        if(start==s.length())
            return true;
        if(memo[start]!=null)
            return memo[start];
        for(int end=start+1;end<=s.length();end++){
            if(wordDict.contains(s.substring(start,end))&& word_break(s,wordDict,end,memo)){
                return memo[start]=true;
            }
        }
        return memo[start]=false;
    }
}
```

### Reference

## [Wildcard Matching]()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## [Word Break II]()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

# Permutation-based DFS

## [\681. Next Closest Time](https://leetcode.com/problems/next-closest-time/)

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## [Letter Combinations of Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

### Analysis

- Data structure
- **Complexity Analysis**
  - Time complexity : O(3*N*×4*M*) where `N` is the number of digits in the input that maps to 3 letters (*e.g.* `2, 3, 4, 5, 6, 8`) and `M` is the number of digits in the input that maps to 4 letters (*e.g.* `7, 9`), and `N+M` is the total number digits in the input.
  - Space complexity :O(3*N*×4*M*) since one has to keep 3^N \times 4^M3*N*×4*M* solutions.

### Solution

```java
class Solution {
    Map<String,String> phone=new HashMap<String,String>(){{
         put("2", "abc");
    put("3", "def");
    put("4", "ghi");
    put("5", "jkl");
    put("6", "mno");
    put("7", "pqrs");
    put("8", "tuv");
    put("9", "wxyz");
    }};
    
    List<String> output=new ArrayList<String>();
    
    public void backtrack(String combination, String next_digits){
        if(next_digits.length()==0){
            output.add(combination);
        }else{
            String digit= next_digits.substring(0,1);
            String letters=phone.get(digit);
            for(int i=0;i<letters.length();i++){
                String letter=letters.substring(i,i+1);
                backtrack(combination+letter,next_digits.substring(1));
            }
        }
        
        
        
    }
    
    public List<String> letterCombinations(String digits) {
        if(digits.length()!=0)
            backtrack("",digits);
        return output;
    }
}
```

### Reference

[Solution](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution/)



## [\79. Word Search](https://leetcode.com/problems/word-search/)

### Analysis

- Data structure
- **Complexity Analysis**
  - Time Complexity:O(*N*⋅4*L*) where N*N* is the number of cells in the board and L*L* is the length of the word to be matched.
  - Space Complexity:  O(MxN) ; M: the length of the row ;N: the length of the column

### Solution

```java
class Solution {
    private boolean[][] marked;
    private int[][] direction= {{-1,0},{0,-1},{0,1},{1,0}};
    private int ROW;
    private int COL;
    private char[][] board;
    private String word;
    public boolean exist(char[][] board, String word) {
        this.ROW=board.length;
        if(ROW==0)
            return false;
        this.board=board;
        this.word=word;
        this.COL=board[0].length;
        marked=new boolean[ROW][COL];
        for(int i=0;i<ROW;i++){
            for(int j=0; j<COL;j++){
                if(backtrack(i,j,0))
                   return true;
            }
        }
        return false;
    }
    
    private boolean backtrack(int i, int j, int start){
        if(start==word.length()-1)
            return board[i][j]==word.charAt(start);
        if(board[i][j]==word.charAt(start)){
            marked[i][j]=true;
            for(int k=0;k<4;k++){
                int newX=i+direction[k][0];
                int newY=j+direction[k][1];
                if(inArea(newX,newY)&& !marked[newX][newY]){
                    if(backtrack(newX,newY,start+1)){
                        return true;
                    }
                }
            }
            // 回溯 
            marked[i][j]=false;
        }
        return false;
    }
    
    private boolean inArea(int x,int y){
        return x>=0&& x<ROW&&y>=0&&y<COL;
    }
    
    
}
```

### Reference

[在二维平面上使用回溯法（Python 代码、Java 代码）](https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/)

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

# Graph-base DFS

## [\785. Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/)

### Analysis

I am going to use dfs to solve this problem. My intuition is to color a node blue and color its neighbor red, I am going to use dfs to travse all nodes and color them. And if we find one node and its one of neighbors have the same color, the graph is not bipartie.

- Data structure: Graph/ Stack
- **Complexity Analysis**
  - Time complexcity: O(n+e)
  - Space complexcity: O(n)

### Solution

```java
class Solution {
    public boolean isBipartite(int[][] graph) {
        int n= graph.length;
        int[] color=new int[n];
        Arrays.fill(color,-1);
        
        for(int start=0;start<n;++start){
          if(color[start]==-1){
              Stack<Integer> stack=new Stack();
              stack.push(start);
              color[start]=0;
              while(!stack.empty()){
                  Integer node=stack.pop();
                  for(int nei: graph[node]){
                      if(color[nei]==-1){
                          stack.push(nei);
                          color[nei]=color[node]^ 1;
                      }else if(color[nei]==color[node]){
                          return false;
                      }
                  }
              }
          }  
        }
        return true;
    }
}
```

### Reference

[Solution](https://leetcode.com/problems/is-graph-bipartite/solution/)

## [\685. Redundant Connection II](https://leetcode.com/problems/redundant-connection-ii/)

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java
class Solution {  
    int[] anc;//并查集
    int[] parent;// record the father of every node to find the one with 2 fathers,记录每个点的父亲，为了找到双入度点
    public int[] findRedundantDirectedConnection(int[][] edges) {
        anc=new int[edges.length+1];
        parent=new int[edges.length+1];
        int[] edge1=null;
        int[] edge2=null;
        int[] lastEdgeCauseCircle=null;
        for (int[] pair:edges){
            int u=pair[0];
            int v=pair[1];
            
            if(anc[u]==0) anc[u]=u;
            if(anc[v]==0) anc[v]=v;//init the union-find set  初始化并查集
                
            if (parent[v]!=0){// node v already has a father, so we just skip the union of this edge and check if there will be a circle ，跳过 edge2,并记下 edge1,edge2
                edge1=new int[]{parent[v],v};
                edge2=pair;
            } else {
                parent[v]=u;
                int ancU=find(u);
                int ancV=find(v);
                if(ancU!=ancV){
                    anc[ancV]=ancU;
                } else { //meet a circle , 碰到了环
                    lastEdgeCauseCircle=pair;
                }
            }
        }
        if (edge1!=null&&edge2!=null) return lastEdgeCauseCircle==null?edge2:edge1; //如果是情况2、3，则根据有没有碰到环返回 edge1 或 edge2
        else return lastEdgeCauseCircle; //否则就是情况1，返回那个导致环的最后出现的边。
    }
     
    private int find(int node){
        if (anc[node]==node) return node;
        anc[node]=find(anc[node]);
        return anc[node];
    }
}
```

### Reference

[[中文]清晰易懂的思路](https://leetcode.com/problems/redundant-connection-ii/discuss/278105/topic)

## [\886. Possible Bipartition](https://leetcode.com/problems/possible-bipartition/)

### Analysis

- Data structure: Hashmap/ Arraylist
- Complexity Analysis
  - Time: O(N+E)
  - Space: O(N+E)

### Solution

```java
class Solution {
    ArrayList<Integer>[] graph;
    Map<Integer,Integer> color;
    
    public boolean possibleBipartition(int N, int[][] dislikes) {
        graph=new ArrayList[N+1];
        for(int i=1;i<=N;++i){
            graph[i]=new ArrayList<Integer>();
        }
        
        for(int[] edge:dislikes){
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        
        color=new HashMap();
        for(int node=1;node<=N;++node){
            if(!color.containsKey(node)){
                if(!dfs(node,0))
                    return false;
            }else
                continue;
        }
        return true;
    }
    
    public boolean dfs(int node,int c){
        if(color.containsKey(node))
            return color.get(node)==c;
        color.put(node,c);
        
        for(int nei:graph[node])
            if(!dfs(nei,c^1))
                return false;
        return true;
    }
}
```

### Reference

[可能的二分法](https://leetcode-cn.com/problems/possible-bipartition/solution/ke-neng-de-er-fen-fa-by-leetcode/)

## [\980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/)

### Analysis

- Data structure
- **Complexity Analysis**
  - Time Complexity: \mathcal{O}(3^N)O(3*N*)
    - Although technically we have 4 directions to explore at each step, we have *at most* 3 directions to try at any moment except the first step. The last direction is the direction where we came from, therefore we don't need to explore it, since we have been there before.
    - In the worst case where none of the cells is an obstacle, we have to explore each cell. Hence, the time complexity of the algorithm is \mathcal{O}(4 * 3 ^{(N-1)}) = \mathcal{O}(3^N)O(4∗3(*N*−1))=O(3*N*).
  - Space Complexity: \mathcal{O}(N)O(*N*)
    - Thanks to the in-place technique, we did not use any additional memory to keep track of the state.
    - On the other hand, we apply recursion in the algorithm, which could incur \mathcal{O}(N)O(*N*) space in the function call stack.
    - Hence, the overall space complexity of the algorithm is \mathcal{O}(N)O(*N*).

### Solution： backtrack

```java
class Solution {
    int rows, cols;
    int[][] grid;
    int path_count;

    protected void backtrack(int row, int col, int remain) {
        // base case for the termination of backtracking
        if (this.grid[row][col] == 2 && remain == 1) {
            // reach the destination
            this.path_count += 1;
            return;
        }

        // mark the square as visited. case: 0, 1, 2
        int temp = grid[row][col];
        grid[row][col] = -4;
        remain -= 1; // we now have one less square to visit

        // explore the 4 potential directions around
        int[] row_offsets = {0, 0, 1, -1};
        int[] col_offsets = {1, -1, 0, 0};
        for (int i = 0; i < 4; ++i) {
            int next_row = row + row_offsets[i];
            int next_col = col + col_offsets[i];

            if (0 > next_row || next_row >= this.rows ||
                0 > next_col || next_col >= this.cols)
                // invalid coordinate
                continue;

            if (grid[next_row][next_col] < 0)
                // either obstacle or visited square
                continue;

            backtrack(next_row, next_col, remain);
        }

        // unmark the square after the visit
        grid[row][col] = temp;
    }

    public int uniquePathsIII(int[][] grid) {
        int non_obstacles = 0, start_row = 0, start_col = 0;

        this.rows = grid.length;
        this.cols = grid[0].length;

        // step 1). initialize the conditions for backtracking
        //   i.e. initial state and final state
        for (int row = 0; row < rows; ++row)
            for (int col = 0; col < cols; ++col) {
                int cell = grid[row][col];
                if (cell >= 0)
                    non_obstacles += 1;
                if (cell == 1) {
                    start_row = row;
                    start_col = col;
                }
            }

        this.path_count = 0;
        this.grid = grid;

        // kick-off the backtracking
        backtrack(start_row, start_col, non_obstacles);

        return this.path_count;
    }
}
```

### Reference

[Solution][https://leetcode.com/problems/unique-paths-iii/solution/]

## [\399. Evaluate Division](https://leetcode.com/problems/evaluate-division/)

### Analysis

- Data structure: Graph constructed by HashMap
- **Complexity Analysis**
  - Time Complexity: \mathcal{O}(M \cdot N)O(*M*⋅*N*)
    - First of all, we iterate through the equations to build a graph. Each equation takes \mathcal{O}(1)O(1) time to process. Therefore, this step will take \mathcal{O}(N)O(*N*) time in total.
    - For each query, we need to traverse the graph. In the worst case, we might need to traverse the entire graph, which could take \mathcal{O}(N)O(*N*). Hence, in total, the evaluation of queries could take M \cdot \mathcal{O}(N) = \mathcal{O}(M \cdot N)*M*⋅O(*N*)=O(*M*⋅*N*).
    - To sum up, the overall time complexity of the algorithm is \mathcal{O}(N) + \mathcal{O}(M \cdot N) = \mathcal{O}(M \cdot N)O(*N*)+O(*M*⋅*N*)=O(*M*⋅*N*)
  - Space Complexity: \mathcal{O}(N)O(*N*)
    - We build a graph out the equations. In the worst case where there is no overlapping among the equations, we would have N*N* edges and 2N2*N* nodes in the graph. Therefore, the sapce complexity of the graph is \mathcal{O}(N + 2N) = \mathcal{O}(3N) = \mathcal{O}(N)O(*N*+2*N*)=O(3*N*)=O(*N*).
    - Since we employ the recursion in the backtracking, we would consume additional memory in the function call stack, which could amount to \mathcal{O}(N)O(*N*) space.
    - In addition, we used a set `visited` to keep track of the nodes we visited during the backtracking. The space complexity of the `visited` set would be \mathcal{O}(N)O(*N*).
    - To sum up, the overall space complexity of the algorithm is \mathcal{O}(N) + \mathcal{O}(N) + \mathcal{O}(N) = \mathcal{O}(N)O(*N*)+O(*N*)+O(*N*)=O(*N*).
    - Note that we did not take into account the space needed to hold the results. Otherwise, the total space complexity would be \mathcal{O}(N + M)O(*N*+*M*)

### Solution

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values,
            List<List<String>> queries) {

        HashMap<String, HashMap<String, Double>> graph = new HashMap<>();

        // Step 1). build the graph from the equations
        for (int i = 0; i < equations.size(); i++) {
            List<String> equation = equations.get(i);
            String dividend = equation.get(0), divisor = equation.get(1);
            double quotient = values[i];

            if (!graph.containsKey(dividend))
                graph.put(dividend, new HashMap<String, Double>());
            if (!graph.containsKey(divisor))
                graph.put(divisor, new HashMap<String, Double>());

            graph.get(dividend).put(divisor, quotient);
            graph.get(divisor).put(dividend, 1 / quotient);
        }

        // Step 2). Evaluate each query via bactracking (DFS)
        // by verifying if there exists a path from dividend to divisor
        double[] results = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String dividend = query.get(0), divisor = query.get(1);

            if (!graph.containsKey(dividend) || !graph.containsKey(divisor))
                results[i] = -1.0;
            else if (dividend == divisor)
                results[i] = 1.0;
            else {
                HashSet<String> visited = new HashSet<>();
                results[i] = backtrackEvaluate(graph, dividend, divisor, 1, visited);
            }
        }

        return results;
    }

    private double backtrackEvaluate(HashMap<String, HashMap<String, Double>> graph, String currNode, String targetNode, double accProduct, Set<String> visited) {

        // mark the visit
        visited.add(currNode);
        double ret = -1.0;

        Map<String, Double> neighbors = graph.get(currNode);
        if (neighbors.containsKey(targetNode))
            ret = accProduct * neighbors.get(targetNode);
        else {
            for (Map.Entry<String, Double> pair : neighbors.entrySet()) {
                String nextNode = pair.getKey();
                if (visited.contains(nextNode))
                    continue;
                ret = backtrackEvaluate(graph, nextNode, targetNode,
                        accProduct * pair.getValue(), visited);
                if (ret != -1.0)
                    break;
            }
        }

        // unmark the visit, for the next backtracking
        visited.remove(currNode);
        return ret;
    }
}
```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

# Array-base DFS

## [\733. Flood Fill](https://leetcode.com/problems/flood-fill/)

### Analysis

- Data structure: Matrix
- **Complexity Analysis**
  - Time complexcity: O(n)
  - Space complexcity: O(n)

### Solution

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int color=image[sr][sc];
        if(color!=newColor)  dfs(image,sr,sc,color,newColor);
        return image;
    }
    
    public void dfs(int[][] image,int r,int c,int color, int newColor){
        if(image[r][c]==color){
            image[r][c]=newColor;
            if(r>=1) dfs(image,r-1,c,color,newColor);
            if(c>=1) dfs(image,r,c-1,color,newColor);
            if(r+1<image.length) dfs(image,r+1,c,color,newColor);
            if(c+1<image[0].length) dfs(image,r,c+1,color,newColor);
        }
    }
}
```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference