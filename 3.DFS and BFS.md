# 总结

分类：按照该算法在不同数据结构的应用进行分类

## Reference

- [别再埋头刷LeetCode之：北美算法面试的题目分类，按类型和规律刷题，事半功倍](https://zhuanlan.zhihu.com/p/89392459)



## BFS in Tree

## [Binary Tree Level Order Traversal]()

### Approach 1: DFS

### Analysis

- Data structure: Arraylist
- Complexity Analysis
  - Time complexity : O(*N*) since each node is processed exactly once.
  - Space complexity : O(*N*) to keep the output structure which contains `N` node values.

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<List<Integer>> result =new ArrayList<>();
    public void helper(TreeNode node, int levels){
        if(result.size()==levels) result.add(new ArrayList<Integer>());
        result.get(levels).add(node.val);
        if(node.left!=null) helper(node.left,levels+1);
        if(node.right!=null) helper(node.right,levels+1);
    }
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return result;
        helper(root,0);
        return result;
    }
}
```

### Approach 1: BFS

### Analysis

- Data structure: Arraylist
- The zero level contains only one node `root`. The algorithm is simple :
  - Initiate queue with a `root` and start from the level number `0` : `level = 0`.
  - While queue is not empty :
    - Start the current level by adding an empty list into output structure `levels`.
    - Compute how many elements should be on the current level : it's a queue length.
    - Pop out all these elements from the queue and add them into the current level.
    - Push their child nodes into the queue for the next level.
    - Go to the next level `level++`.
- Complexity Analysis
  - Time complexity : O(*N*) since each node is processed exactly once.
  - Space complexity : O(*N*) to keep the output structure which contains `N` node values.

### Solution

```java
class Solution {
  public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();
    if (root == null) return levels;

    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    int level = 0;
    while ( !queue.isEmpty() ) {
      // start the current level
      levels.add(new ArrayList<Integer>());

      // number of elements in the current level
      int level_length = queue.size();
      for(int i = 0; i < level_length; ++i) {
        TreeNode node = queue.remove();

        // fulfill the current level
        levels.get(level).add(node.val);

        // add child nodes of the current level
        // in the queue for the next level
        if (node.left != null) queue.add(node.left);
        if (node.right != null) queue.add(node.right);
      }
      // go to next level
      level++;
    }
    return levels;
  }
}
```

### Reference

- [102. Binary Tree Level Order Traversal Discussion](https://leetcode.com/articles/binary-tree-level-order-traversal/)

## [107. Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)

### Approach 1: BFS

### Analysis

- Data structure: Queue/Linkedlist
- Complexity Analysis
  - Time complexity : O(*N*) since each node is processed exactly once.
  - Space complexity : O(*N*) to keep the output structure which contains `N` node values.

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result= new ArrayList<>();
        if(root==null) return result;
        Queue<TreeNode> queue=new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int size= queue.size();
            List<Integer> level=new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode node= queue.poll();
                level.add(node.val);
                if(node.left!=null) queue.offer(node.left);
                if(node.right!=null) queue.offer(node.right);
            }
            result.add(level);
        }
        Collections.reverse(result);
        return result;
    }
}
```

### Approach 1: DFS

- Data structure: List
- Complexity Analysis
  - Time complexity : O(*N*) since each node is processed exactly once.
  - Space complexity : O(*N*) to keep the output structure which contains `N` node values.

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result=new ArrayList<>();
        if(root==null) return result;
        levelMaker(result,root,0);
        return result;
        }
    public void levelMaker(List<List<Integer>> list,TreeNode root, int level){
        if(root==null) return;
        if(level>=list.size()) list.add(0,new ArrayList<Integer>());
        //程序执行到最底层，然后把值加入到index为0的位置，例：3-2-1；倒数第二次，加入到index为1的位置，例：3-1-1
        list.get(list.size()-level-1).add(root.val);
        levelMaker(list,root.left,level+1);
        levelMaker(list,root.right,level+1);
    }

}
```

### Reference

- [My DFS and BFS java solution](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/discuss/34981/My-DFS-and-BFS-java-solution)

## [\103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal)

### Analysis

- Data structure: Queue;Linkedlist
- Complexity Analysis
  - Time Complexity: O(*N*), where N*N* is the number of nodes in the tree.
  - Space Complexity: O(*N*) where N*N* is the number of nodes in the tree

### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res=new ArrayList<>();
        if(root==null) return res;
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        boolean isReverse=false;
        while(!queue.isEmpty()){
            LinkedList<Integer> oneLevel=new LinkedList<>();
            //必须单独使用count存储queue元素数量，如果直接使用queue.size()，循环里面queue数量会变化，出错
            int count=queue.size();
            for(int i=0;i<count;i++){
                TreeNode node= queue.poll();
                if(!isReverse) 
                    oneLevel.add(node.val);
                else 
                    oneLevel.addFirst(node.val);
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            isReverse=!isReverse;
            res.add(oneLevel);
        }
        return res;
    }
}
```

### Reference

- [LinkedList addFirst() Method in Java](https://www.geeksforgeeks.org/linkedlist-addfirst-method-in-java/)
- [Java双端队列Deque使用详解](https://blog.csdn.net/devnn/article/details/82716447?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
- [1ms 简洁Java 没有reverse哦 击败99.83% 带清晰注释](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/1ms-jian-ji-java-by-wilisuse/)

## BFS in Graph

## [\133. Clone Graph](https://leetcode.com/problems/clone-graph/solution/)

### Approach-BFS

### Analysis

- **Algorithm**
  1. We will use a hash map to store the reference of the copy of all the nodes that have already been visited and copied. The `key` for the hash map would be the node of the original graph and corresponding `value` would be the corresponding cloned node of the cloned graph. The `visited` is used to prevent cycles and get the cloned copy of a node.
  2. Add the first node to the queue. Clone the first node and add it to `visited` hash map.
  3. Do the BFS traversal.
     - Pop a node from the front of the queue.
     - Visit all the neighbors of this node.
     - If any of the neighbors was already visited then it must be present in the `visited` dictionary. Get the clone of this neighbor from `visited` in that case.
     - Otherwise, create a clone and store in the `visited`.
     - Add the clones of the neighbors to the corresponding list of the clone node.
- Data structure: HashMap/Queue/LinkedList
- Complexity Analysis
  - Time Complexity : *O*(*N*) since we process each node exactly once.
  - Space Complexity : O(N) This space is occupied by the `visited` dictionary and in addition to that, space would also be occupied by the queue since we are adopting the BFS approach here

### Solution

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;

    public Node() {}

    public Node(int _val,List<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) {
            return node;
        }

        // Hash map to save the visited node and it's respective clone
        // as key and value respectively. This helps to avoid cycles.
        HashMap<Node, Node> visited = new HashMap();

        // Put the first node in the queue
        LinkedList<Node> queue = new LinkedList<Node> ();
        queue.add(node);
        // Clone the node and put it in the visited dictionary.
        visited.put(node, new Node(node.val, new ArrayList()));

        // Start BFS traversal
        while (!queue.isEmpty()) {
            // Pop a node say "n" from the from the front of the queue.
            Node n = queue.remove();
            // Iterate through all the neighbors of the node "n"
            for (Node neighbor: n.neighbors) {
                if (!visited.containsKey(neighbor)) {
                    // Clone the neighbor and put in the visited, if not present already
                    visited.put(neighbor, new Node(neighbor.val, new ArrayList()));
                    // Add the newly encountered node to the queue.
                    queue.add(neighbor);
                }
                // Add the clone of the neighbor to the neighbors of the clone node "n".
                visited.get(n).neighbors.add(visited.get(neighbor));
            }
        }

        // Return the clone of the node from visited.
        return visited.get(node);
    }
}
```

### Approach-DFS

### Analysis

- Data structure: HashMap
- Complexity Analysis
  -  Time complexity :O(N+M) 
  - Space complexity :O(N)

### Solution

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;

    public Node() {}

    public Node(int _val,List<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
    private HashMap <Node, Node> visited = new HashMap <> ();
    public Node cloneGraph(Node node) {
        if (node == null) {
            return node;
        }

        // If the node was already visited before.
        // Return the clone from the visited dictionary.
        if (visited.containsKey(node)) {
            return visited.get(node);
        }

        // Create a clone for the given node.
        // Note that we don't have cloned neighbors as of now, hence [].
        Node cloneNode = new Node(node.val, new ArrayList());
        // The key is original node and value being the clone node.
        visited.put(node, cloneNode);

        // Iterate through the neighbors to generate their clones
        // and prepare a list of cloned neighbors to be added to the cloned node.
        for (Node neighbor: node.neighbors) {
            cloneNode.neighbors.add(cloneGraph(neighbor));
        }
        return cloneNode;
    }
}
```

### Reference

- [克隆图](https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode/)

## [\127. Word Ladder](https://leetcode.com/problems/word-ladder/)

### Analysis

- **Algorithm**

  1. Do the pre-processing on the given `wordList` and find all the possible generic/intermediate states. Save these intermediate states in a dictionary with key as the intermediate word and value as the list of words which have the same intermediate word.

  2. Push a tuple containing the `beginWord` and `1` in a queue. The `1` represents the level number of a node. We have to return the level of the `endNode` as that would represent the shortest sequence/distance from the `beginWord`.

  3. To prevent cycles, use a visited dictionary.

  4. While the queue has elements, get the front element of the queue. Let's call this word as `current_word`.

  5. Find all the generic transformations of the `current_word` and find out if any of these transformations is also a transformation of other words in the word list. This is achieved by checking the `all_combo_dict`.

  6. The list of words we get from `all_combo_dict` are all the words which have a common intermediate state with the `current_word`. These new set of words will be the adjacent nodes/words to `current_word` and hence added to the queue.

  7. Hence, for each word in this list of intermediate words, append `(word, level + 1)` into the queue where `level` is the level for the `current_word`.

  8. Eventually if you reach the desired word, its level would represent the shortest transformation sequence length.

     > Termination condition for standard BFS is finding the end word.

- Data structure: Queue/HashMap/Pair

- Complexity Analysis

  - Time Complexity:O*(*M*×*N*), where M* is the length of words and N is the total number of words in the input word list. Finding out all the transformations takes M*M* iterations for each of the N words. Also, breadth first search in the worst case might go to each of the N words.
  - Space Complexity:O*(*M*×*N*), to store all M transformations for each of the N words, in the `all_combo_dict` dictionary. Visited dictionary is of N* size. Queue for BFS in worst case would need space for all N words

  ### Solution

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        
        int L= beginWord.length();
        Map<String,List<String>> allComboDict=new HashMap<>();
        wordList.forEach(word->{
            for(int i=0;i<L;i++){
                String newWord=word.substring(0,i)+"*"+word.substring(i+1,L);
                List<String> transformation= allComboDict.getOrDefault(newWord,new ArrayList<>());
                transformation.add(word);
                allComboDict.put(newWord,transformation);
            }
        });
        
        
        Queue<Pair<String, Integer>> Q = new LinkedList<>();
        Q.add(new Pair(beginWord,1));
        Map<String,Boolean> visited=new HashMap<>();
        visited.put(beginWord,true);
        
        while(!Q.isEmpty()){
            Pair<String,Integer> node=Q.remove();
            String word=node.getKey();
            int level=node.getValue();
            for(int i=0;i<L;i++){
                String newWord=word.substring(0,i)+"*"+word.substring(i+1,L);
                for(String adjacentWord: allComboDict.getOrDefault(newWord,new ArrayList<>())){
                    if(adjacentWord.equals(endWord)) return level+1;
                    if(!visited.containsKey(adjacentWord)){
                        visited.put(adjacentWord,true);
                        Q.add(new Pair(adjacentWord,level+1));
                    }
                }
                
            }
        }
        return 0;
    }
}
```

### Reference

- [单词接龙](https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/)
- [Java substring() 方法](https://www.runoob.com/java/java-string-substring.html)
- [Java 8 forEach使用](https://blog.csdn.net/u014042066/article/details/76286033)