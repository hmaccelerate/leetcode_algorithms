## [\678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)

### Analysis

In order to check whether the string is valid, I am goint to use the "`balance`": the number of extra, open left brackets as we parsed through the string. 

For example, when checking whether '(()())' is valid, we had a balance of `1, 2, 1, 2, 1, 0` as we parse through the string: `'('` has 1 left bracket, `'(('` has 2, `'(()'` has 1, and so on. This means that after parsing the first `i` symbols, (which may include asterisks,) we only need to keep track of what the `balance` could be.

**Algorithm**

Let `lo, hi` respectively be the smallest and largest possible number of open left brackets after processing the current character in the string.

If we encounter a left bracket (`c == '('`), then `lo++`, otherwise we could write a right bracket, so `lo--`. If we encounter what can be a left bracket (`c != ')'`), then `hi++`, otherwise we must write a right bracket, so `hi--`. If `hi < 0`, then the current prefix can't be made valid no matter what our choices are. Also, we can never have less than `0` open left brackets. At the end, we should check that we can have exactly 0 open left brackets.

- Data structure
- Complexity Analysis
  - Time Complexity: *O*(*N*), where N*N* is the length of the string. We iterate through the string once.
  - Space Complexity: *O*(1), the space used by our `lo` and `hi` pointers. However, creating a new character array will take O(N)space.

### Solution

```java
class Solution {
    public boolean checkValidString(String s) {
        int lo=0,hi=0;
        for(char c: s.toCharArray()){
            lo+= c=='('? 1:-1;
            hi+= c !=')'? 1:-1;
            if(hi<0) break;
            lo=Math.max(lo,0);
        }
        return lo==0;
    }
}
```

### Reference

## [57. Insert Interval](https://leetcode.com/problems/insert-interval/)

### Analysis

- Data structure
- **Complexity Analysis**
  - Time complexity : O(*N*) since it's one pass along the input array.
  - Space complexity : O(*N*) to keep the output.

### Solution

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        // init data
        int newStart=newInterval[0],newEnd=newInterval[1];
        int idx=0,n=intervals.length;
        LinkedList<int[]> output=new LinkedList<int[]>();
        
        //add all intervals starting before newInterval
        while(idx<n&& newStart>intervals[idx][0])
            output.add(intervals[idx++]);
        
        //add newInterval
        int[] interval=new int[2];
        //if there is no overlap, just add the interval
        if(output.isEmpty()|| output.getLast()[1]<newStart)
            output.add(newInterval);
        // if there is a overlap,merge with the last interval
        else{
            interval=output.removeLast();
            interval[1]=Math.max(interval[1],newEnd);
            output.add(interval);
        }
        
        while(idx<n){
            interval=intervals[idx++];
            int start=interval[0],end=interval[1];
            //if there is no overlap,just add the next interval
            if(output.getLast()[1]<start)
                output.add(interval);
            else{
                interval=output.removeLast();
                interval[1]=Math.max(interval[1],end);
                output.add(interval);
            }
        }
        return output.toArray(new int[output.size()][2]);
    }
}
```

### Reference

[Solution](https://leetcode.com/problems/insert-interval/solution/)

## [Gas station](https://leetcode.com/problems/gas-station/)

### Analysis

- Data structure
- **Complexity Analysis**
  - **Complexity Analysis**
    - Time complexity : O(*N*) since there is only one loop over all stations here.
    - Space complexity : O(1) since it's a constant space solution.

### Solution

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n=gas.length;
        int total_tank=0;
        int curr_tank=0;
        int start_station=0;
        for(int i=0;i<n;i++){
            total_tank+=gas[i]-cost[i];
            curr_tank+=gas[i]-cost[i];
            if(curr_tank<0){
                curr_tank=0;
                start_station=i+1;
            }
        }
        return total_tank>=0? start_station:-1;
    }
}
```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference

## []()

### Analysis

- Data structure
- **Complexity Analysis**

### Solution

```java

```

### Reference